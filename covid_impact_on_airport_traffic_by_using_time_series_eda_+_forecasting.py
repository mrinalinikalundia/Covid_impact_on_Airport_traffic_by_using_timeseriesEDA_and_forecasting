# -*- coding: utf-8 -*-
"""Covid_impact_on_airport_traffic by using time series EDA + Forecasting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15QuX3QsAQAQivnLwAScogMrgys-YKNcN
"""

#import libaries
import numpy as np
import pandas as pd

df=pd.read_csv('/content/covid_impact_on_airport_traffic.csv.zip')

df

df.info()

df.isna().sum()

df.nunique()

import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px

plt.figure(figsize=(8,4))
fig4 = sns.countplot(x = 'Country', data = df , palette='summer')
fig4.set_xticklabels(fig4.get_xticklabels())
fig4.set_title("Count for various Country")
plt.show();

plt.figure(figsize=(20,6))
fig1 = sns.countplot(x = 'AirportName', data = df , palette='rainbow_r')
fig1.set_xticklabels(fig1.get_xticklabels(), rotation=90)
fig1.set_title("Count for various Airports")
plt.show();

plt.figure(figsize=(20,6))
fig2 = sns.countplot(x = 'City', data = df , palette='viridis')
fig2.set_xticklabels(fig2.get_xticklabels(), rotation=90)
fig2.set_title("Count for various City")
plt.show();

plt.figure(figsize=(20,6))
fig3 = sns.countplot(x = 'State', data = df , palette='cividis')
fig3.set_xticklabels(fig3.get_xticklabels(), rotation=90)
fig3.set_title("Count for various State")
plt.show();

sns.kdeplot(df['PercentOfBaseline'],shade=True)
plt.title("Distribution of Percent of Baseline for full data")
plt.show();

percentofbaseline_mean_by_country = df.groupby('Country', as_index=False) \
                                        .agg({'PercentOfBaseline': 'mean'}) \
                                        .rename(columns={'PercentOfBaseline': 'PercentOfBaseline_mean'}) \
                                        .sort_values('PercentOfBaseline_mean', ascending=False)

percentofbaseline_mean_by_country

sns.set_theme(style="whitegrid", palette="light:salmon_r", rc={'figure.figsize': (20, 5)})
ax = sns.barplot(data=percentofbaseline_mean_by_country, x='Country', y='PercentOfBaseline_mean')
ax.set_title('Percent of baseline mean by country')
ax.set_xlabel('Percent of baseline mean')
ax.set_ylabel('Country')
sns.despine()

PercentOfBaseline_by_Date = df.groupby('Date', as_index=False) \
                                .agg({'PercentOfBaseline': 'mean'})

ax = sns.lineplot(x='Date', y='PercentOfBaseline', data=PercentOfBaseline_by_Date)
ax.set_ylabel('Percent of baseline')
ax.set_xlabel('Date')
ax.set_title('Percent of baseline by date')
sns.despine()

min_perpercentofbase = PercentOfBaseline_by_Date.PercentOfBaseline.min()

PercentOfBaseline_by_Date.query('PercentOfBaseline == @min_perpercentofbase')

df.query("Date == '2020-08-17'")

df_city = df.groupby('City', as_index=False) \
            .agg({'PercentOfBaseline': 'mean'}) \
            .rename(columns={'PercentOfBaseline': 'PercentOfBaseline_mean'}) \
            .sort_values('PercentOfBaseline_mean', ascending=False)

sns.set_theme(style="whitegrid", rc={'figure.figsize': (8, 16)})
ax = sns.barplot(data=df_city, x='PercentOfBaseline_mean', y='City')

df_state = df.groupby('State', as_index=False) \
            .agg({'PercentOfBaseline': 'mean'}) \
            .rename(columns={'PercentOfBaseline': 'PercentOfBaseline_mean'}) \
            .sort_values('PercentOfBaseline_mean', ascending=False)

sns.set_theme(style="whitegrid", rc={'figure.figsize': (8, 16)})
ax = sns.barplot(data=df_state, x='PercentOfBaseline_mean', y='State')

df1 = df.groupby("AirportName")['PercentOfBaseline'].mean().sort_values(ascending = False).reset_index()
sns.set(font_scale =1.2)
plt.figure(figsize = [10,10])
sns.barplot(data = df1, x = 'PercentOfBaseline', y = 'AirportName',palette = 'crest')
plt.xlabel('Percent of baseline')
plt.ylabel("Airport name")

df["lon"] = df.Centroid.apply(lambda x: x.split(" ")[0].replace("POINT("," "))
df["lat"] = df.Centroid.apply(lambda x: x.split(" ")[1].replace(")"," "))

df1 = df.groupby(["Country","City",'lat','lon'])['PercentOfBaseline'].mean().sort_values(ascending = False).reset_index()
fig = px.scatter_geo(df1,
                     lat='lat',
                     lon='lon',
                     hover_name="Country",
                     color = 'Country',
                     hover_data = ['PercentOfBaseline',"City"],
                     labels = {"PercentOfBaseline":"Percent of Baseline"}
                     
                    )
fig.update_geos(showocean = True,
                oceancolor = 'LightCyan',
                lakecolor = 'LightSteelBlue',
                showlakes = True,
               
               )
fig.show()

data = df.drop(columns = ['AggregationMethod','Version','Centroid','ISO_3166_2','Geography','lon','lat'])

data.head()

fig5 = sns.pairplot(data,hue='Country',height=5,palette='husl',aspect=1)
fig5._legend.remove()
plt.title("Distribution of Percent of Baseline for different countries")
plt.legend(loc = 'upper right',bbox_to_anchor=(1.2, 0., 0.5, 0.5))
plt.show();

#Analyse Australia

data_aus = data[data['Country']=='Australia']

data_aus

data_aus.set_index('Date',inplace=True)

data_aus

data_aus = data_aus.drop(columns=['AirportName','City','State','Country'])

data_aus.head()

plt.figure(figsize=(20,10))
plt.plot(data_aus['PercentOfBaseline'])
plt.title("Plot for PercentOfBaseline Vs Time for Australia")
plt.show();

from statsmodels.tsa.stattools import adfuller
print('Results of Dickey-Fuller Test:')
dftest = adfuller(data_aus['PercentOfBaseline'], autolag='AIC')
dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])
for key,value in dftest[4].items():
    dfoutput['Critical Value (%s)'%key] = value
print(dfoutput)

from statsmodels.tsa.stattools import kpss
#define KPSS
print ('Results of KPSS Test:')
kpsstest = kpss(data_aus['PercentOfBaseline'], regression='c')
kpss_output = pd.Series(kpsstest[0:3], index=['Test Statistic','p-value','Lags Used'])
for key,value in kpsstest[3].items():
    kpss_output['Critical Value (%s)'%key] = value
print (kpss_output)

data_aus['diff'] = data_aus['PercentOfBaseline'] - data_aus['PercentOfBaseline'].shift(1)

plt.figure(figsize=(20,10))
plt.plot(data_aus['diff'])
plt.title("Plot for lagged PercentOfBaseline Vs Time for Australia")
plt.show();

print('Results of Dickey-Fuller Test:')
dftest = adfuller(data_aus['diff'].dropna(), autolag='AIC')
dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])
for key,value in dftest[4].items():
    dfoutput['Critical Value (%s)'%key] = value
print(dfoutput)

print ('Results of KPSS Test:')
kpsstest = kpss(data_aus['diff'].dropna(), regression='c')
kpss_output = pd.Series(kpsstest[0:3], index=['Test Statistic','p-value','Lags Used'])
for key,value in kpsstest[3].items():
    kpss_output['Critical Value (%s)'%key] = value
print (kpss_output)

from statsmodels.graphics.tsaplots import plot_acf,plot_pacf
plot_acf(data_aus['diff'].dropna(),zero=False)
plt.xlim(0,20)
plt.xticks(np.arange(0,20,1))
plt.show();

plot_pacf(data_aus['diff'].dropna(),zero=False,lags=40,method='ols',alpha=0.05)
plt.xticks(np.arange(0,40,2))
plt.show();

df1 = pd.DataFrame(data_aus['diff'])

df1.dropna(inplace=True)

from statsmodels.tsa.arima_model import ARMA

# Create Training and Test
train = df1.iloc[:212]
test = df1.iloc[212:]
# Build Model
model = ARMA(train, order=(6,0))  
fitted = model.fit()  
print(fitted.summary())

# Forecast
fc, se, conf = fitted.forecast(44, alpha=0.05);

# Make as pandas series
fc_series = pd.Series(fc, index=test.index)
lower_series = pd.Series(conf[:, 0], index=test.index)
upper_series = pd.Series(conf[:, 1], index=test.index)

# Plot
plt.figure(figsize=(12,5), dpi=100)
plt.plot(train, label='training')
plt.plot(test, label='actual',color='r')
plt.plot(fc_series, label='forecast',color='g')
plt.fill_between(lower_series.index, lower_series, upper_series,color='g', alpha=.05)
plt.title('Forecast vs Actuals')
plt.legend(loc='best', fontsize=8)
plt.show()

#Analyse Canada

data_can = data[data['Country']=='Canada']

df2 = pd.DataFrame(data_can.groupby('Date',as_index=True)['PercentOfBaseline'].mean())

plt.figure(figsize=(20,10))
plt.plot(df1)
plt.title("Plot of Canada average PercentOfBaseline Vs Time")
plt.show()

print('Results of Dickey-Fuller Test:')
dftest = adfuller(df2['PercentOfBaseline'], autolag='AIC')
dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])
for key,value in dftest[4].items():
    dfoutput['Critical Value (%s)'%key] = value
print(dfoutput)

print ('Results of KPSS Test:')
kpsstest = kpss(df2['PercentOfBaseline'].dropna(), regression='c')
kpss_output = pd.Series(kpsstest[0:3], index=['Test Statistic','p-value','Lags Used'])
for key,value in kpsstest[3].items():
    kpss_output['Critical Value (%s)'%key] = value
print (kpss_output)

plot_acf(df2['PercentOfBaseline'],zero=False)
plt.xlim(0,10)
plt.xticks(np.arange(0,10,1))
plt.show()

plot_pacf(df2['PercentOfBaseline'],lags=20,zero=False)
plt.xticks(np.arange(0,20,1))
plt.show()

# Create Training and Test
size = int(len(df2['PercentOfBaseline'])*0.8)
train1 = df2['PercentOfBaseline'].iloc[:size]
test1 = df2['PercentOfBaseline'].iloc[size:]
# Build Model
model1 = ARMA(train1, order=(1,2))  
fitted1 = model1.fit() 
print(fitted1.summary())

# Forecast
fc1, se1, conf1 = fitted.forecast(len(test1), alpha=0.05)  # 95% conf

# Make as pandas series
fc1_series = pd.Series(fc1, index=test1.index)
lower_series1 = pd.Series(conf1[:, 0], index=test1.index)
upper_series1 = pd.Series(conf1[:, 1], index=test1.index)

plt.figure(figsize=(12,5), dpi=100)
plt.plot(train1, label='training')
plt.plot(test1, label='actual',color='r')
plt.plot(fc1_series, label='forecast',color='g')
plt.fill_between(lower_series1.index, lower_series1, upper_series1,color='g', alpha=.05)
plt.title('Forecast vs Actuals')
plt.legend(loc='best', fontsize=8)
plt.show()

